syntax = "proto2";
option objc_class_prefix = "ITM";
package iterm2;

// All requests are wrapped in this message.
message Request {
  optional int64 id = 1;

  optional GetBufferRequest get_buffer_request = 100;
  optional GetPromptRequest get_prompt_request = 101;
  optional TransactionRequest transaction_request = 102;
}

// All responses are wrapped in this message.
message Response {
  optional int64 id = 1;

  optional GetBufferResponse get_buffer_response = 100;
  optional GetPromptResponse get_prompt_response = 101;
  optional TransactionResponse transaction_response = 102;
}

// Requests the contents of a range of lines.
message GetBufferRequest {
  // Leave this empty to use the current session, if any.
  optional string session = 1;

  // Which lines to return?
  optional LineRange line_range = 2;
}

// Contains the contents of a range of lines.
message GetBufferResponse {
  enum Status {
    OK = 0;
    SESSION_NOT_FOUND = 1;
    INVALID_LINE_RANGE = 2;
    REQUEST_MALFORMED = 3;
  }

  optional Status status = 1 [default = OK];

  // Which lines were returned
  optional Range range = 2;

  // Those lines' contents.
  repeated LineContents contents = 3;
}

// Requests metadata about the current shell prompt.
message GetPromptRequest {
  // Leave this empty to use the current session, if any.
  optional string session = 1;
}

// Reponds with metadata about the current shell prompt, if possible.
message GetPromptResponse {
  enum Status {
    OK = 0;
    SESSION_NOT_FOUND = 1;
    REQUEST_MALFORMED = 2;
    PROMPT_UNAVAILABLE = 3;
  }

  optional Status status = 1 [default = OK];

  optional CoordRange prompt_range = 2;
  optional CoordRange command_range = 3;
  optional CoordRange output_range = 4;
}

message TransactionRequest {
  // Set to true to begin a new transaction or false to end the current
  // transaction. The app's main loop will not advance while in a
  // transaction. This effectively freezes time. Keep transactions short.
  optional bool begin = 1;
}

message TransactionResponse {
  enum Status {
    OK = 0;
    NO_TRANSACTION = 1;
    ALREADY_IN_TRANSACTION = 2;
  }
  optional Status status = 1 [default = OK];
}

// Describes a range of lines.
message LineRange {
  // Only one of these fields should be set:
  // ---------------------------------------
  // Return just the current contents of the screen.
  optional bool screen_contents_only = 2;

  // Return the last `trailing lines` of the buffer, which could go back into
  // scrollback history.
  optional int32 trailing_lines = 3;
}

// Describes a range of values.
message Range {
  optional int64 location = 1;
  optional int64 length = 2;
}

// Describes a range of cells.
// |..xxxxx|
// |xxxx...|
// start=(0,2) end=(4, 1)
// The end coordinate is the first cell *after* the end of the range described (so an empty range
// has start == end)
message CoordRange {
  optional Coord start = 1;
  optional Coord end = 2;
}

// Describes a cell's location.
message Coord {
  optional int32 x = 1;
  optional int64 y = 2;
}

// Describes the content of a line.
message LineContents {
  optional string text = 1;

  // Some cells do not contain one code point. Use this to map code points in
  // `text` to a screen position.
  //
  // For example, consider a line of text that appears on your display like:
  // xyz compañía
  //
  // The corresponding value of `text` would be:
  // xyzcompan~i'a
  //
  // Each code point in "xyz", as well as each of the non-accented letters in
  // compañía, takes one cell.
  //
  // The blank following 'z' is an uninitialized cell that has no code points,
  // so the z and the c in `text` are adjacent.
  //
  // The ñ is composed of the letter n and a combining tilde (U+0303)
  // (indicated in our example as ~), while í
  // is composed of the leter i and a combining acute accent (U+0301)
  // (indicated in our example as ').
  //
  // To map code points in `text` to screen positions, `code_points_per_cell`
  // provides the number of code points in each cell. In our example you would
  // get:
  //
  //   num_code_points=1, repeats=3
  //   num_code_points=0, repeats=1
  //   num_code_points=1, repeats=5
  //   num_code_points=2, repeats=2
  //   num_code_points=1, repeats=1
  //
  // Lines usually end with a series of uninitialized cells. These are not
  // included here.
  //
  // Here is psuedocode to interpret code_points_per_cell:
  //
  // text_index_to_screen_coord = {}
  // screen_coord_to_text_index = {}
  // text_index = 0
  // screen_coord = 0
  // for cpps in code_points_per_cell:
  //   repeat cpps.repeats times:
  //     text_index_to_screen_coord[text_index] = screen_coord
  //     screen_coord_to_text_index[screen_coord] = text_index
  //     text_index += cpps.num_code_points
  //     screen_coord += 1
  repeated CodePointsPerCell code_points_per_cell = 2;

  // How does this line end?
  enum Continuation {
    // This line is not wrapped.
    CONTINUATION_HARD_EOL = 1;

    // The next line is a continuation of this line.
    CONTINUATION_SOFT_EOL = 2;
  }
  optional Continuation continuation = 3 [default = CONTINUATION_HARD_EOL];
}

message CodePointsPerCell {
  // Number of code points per cell
  optional int32 num_code_points = 1 [default = 1];

  // Number of adjacent cells with this number of code points (always one or more).
  optional int32 repeats = 2;
}
